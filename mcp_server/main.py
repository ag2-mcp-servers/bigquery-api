# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T01:01:01+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Path, Query, Request

from models import (
    Alt,
    Dataset,
    DatasetList,
    GetIamPolicyRequest,
    GetQueryResultsResponse,
    GetServiceAccountResponse,
    Job,
    JobCancelResponse,
    JobList,
    ListModelsResponse,
    ListRoutinesResponse,
    ListRowAccessPoliciesResponse,
    Model,
    Policy,
    Projection,
    ProjectList,
    QueryRequest,
    QueryResponse,
    Routine,
    SetIamPolicyRequest,
    StateFilter,
    Table,
    TableDataInsertAllRequest,
    TableDataInsertAllResponse,
    TableDataList,
    TableList,
    TestIamPermissionsRequest,
    TestIamPermissionsResponse,
    View1,
)

app = MCPProxy(
    contact={'name': 'Google', 'url': 'https://google.com', 'x-twitter': 'youtube'},
    description='A data platform for customers to create, manage, share and query data.',
    license={
        'name': 'Creative Commons Attribution 3.0',
        'url': 'http://creativecommons.org/licenses/by/3.0/',
    },
    termsOfService='https://developers.google.com/terms/',
    title='BigQuery API',
    version='v2',
    servers=[{'url': 'https://bigquery.googleapis.com/bigquery/v2'}],
)


@app.get(
    '/projects',
    description=""" Lists all projects to which you have been granted any project role. """,
    tags=['bigquery_query_jobs'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_projects_list(
    max_results: Optional[int] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/datasets',
    description=""" Lists all datasets in the specified project to which you have been granted the READER dataset role. """,
    tags=['bigquery_project_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_datasets_list(
    project_id: str = Path(..., alias='projectId'),
    all: Optional[bool] = None,
    filter: Optional[str] = None,
    max_results: Optional[int] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{projectId}/datasets',
    description=""" Creates a new empty dataset. """,
    tags=['bigquery_dataset_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_datasets_insert(
    project_id: str = Path(..., alias='projectId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Dataset = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{projectId}/datasets/{datasetId}',
    description=""" Deletes the dataset specified by the datasetId value. Before you can delete a dataset, you must delete all its tables, either manually or by specifying deleteContents. Immediately after deletion, you can create another dataset with the same name. """,
    tags=['bigquery_dataset_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_datasets_delete(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    delete_contents: Optional[bool] = Query(None, alias='deleteContents'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/datasets/{datasetId}',
    description=""" Returns the dataset specified by datasetID. """,
    tags=['bigquery_dataset_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_datasets_get(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{projectId}/datasets/{datasetId}',
    description=""" Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource. This method supports patch semantics. """,
    tags=['bigquery_dataset_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_datasets_patch(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Dataset = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{projectId}/datasets/{datasetId}',
    description=""" Updates information in an existing dataset. The update method replaces the entire dataset resource, whereas the patch method only replaces fields that are provided in the submitted dataset resource. """,
    tags=['bigquery_dataset_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_datasets_update(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Dataset = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/datasets/{datasetId}/models',
    description=""" Lists all models in the specified dataset. Requires the READER dataset role. After retrieving the list of models, you can get information about a particular model by calling the models.get method. """,
    tags=['bigquery_dataset_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_models_list(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    max_results: Optional[int] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{projectId}/datasets/{datasetId}/models/{modelId}',
    description=""" Deletes the model specified by modelId from the dataset. """,
    tags=['bigquery_model_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_models_delete(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    model_id: str = Path(..., alias='modelId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/datasets/{datasetId}/models/{modelId}',
    description=""" Gets the specified model resource by model ID. """,
    tags=['bigquery_model_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_models_get(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    model_id: str = Path(..., alias='modelId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{projectId}/datasets/{datasetId}/models/{modelId}',
    description=""" Patch specific fields in the specified model. """,
    tags=['bigquery_model_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_models_patch(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    model_id: str = Path(..., alias='modelId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Model = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/datasets/{datasetId}/routines',
    description=""" Lists all routines in the specified dataset. Requires the READER dataset role. """,
    tags=['bigquery_dataset_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_routines_list(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    filter: Optional[str] = None,
    max_results: Optional[int] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    read_mask: Optional[str] = Query(None, alias='readMask'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{projectId}/datasets/{datasetId}/routines',
    description=""" Creates a new routine in the dataset. """,
    tags=['bigquery_routine_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_routines_insert(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Routine = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{projectId}/datasets/{datasetId}/routines/{routineId}',
    description=""" Deletes the routine specified by routineId from the dataset. """,
    tags=['bigquery_routine_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_routines_delete(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    routine_id: str = Path(..., alias='routineId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/datasets/{datasetId}/routines/{routineId}',
    description=""" Gets the specified routine resource by routine ID. """,
    tags=['bigquery_routine_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_routines_get(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    routine_id: str = Path(..., alias='routineId'),
    read_mask: Optional[str] = Query(None, alias='readMask'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{projectId}/datasets/{datasetId}/routines/{routineId}',
    description=""" Updates information in an existing routine. The update method replaces the entire Routine resource. """,
    tags=['bigquery_routine_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_routines_update(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    routine_id: str = Path(..., alias='routineId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Routine = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/datasets/{datasetId}/tables',
    description=""" Lists all tables in the specified dataset. Requires the READER dataset role. """,
    tags=['bigquery_dataset_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_tables_list(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    max_results: Optional[int] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{projectId}/datasets/{datasetId}/tables',
    description=""" Creates a new, empty table in the dataset. """,
    tags=['bigquery_table_operations', 'bigquery_table_data_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_tables_insert(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Table = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{projectId}/datasets/{datasetId}/tables/{tableId}',
    description=""" Deletes the table specified by tableId from the dataset. If the table contains data, all the data will be deleted. """,
    tags=['bigquery_table_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_tables_delete(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    table_id: str = Path(..., alias='tableId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/datasets/{datasetId}/tables/{tableId}',
    description=""" Gets the specified table resource by table ID. This method does not return the data in the table, it only returns the table resource, which describes the structure of this table. """,
    tags=['bigquery_table_operations', 'bigquery_table_data_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_tables_get(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    table_id: str = Path(..., alias='tableId'),
    selected_fields: Optional[str] = Query(None, alias='selectedFields'),
    view: Optional[View1] = None,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/projects/{projectId}/datasets/{datasetId}/tables/{tableId}',
    description=""" Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource. This method supports patch semantics. """,
    tags=['bigquery_table_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_tables_patch(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    table_id: str = Path(..., alias='tableId'),
    autodetect_schema: Optional[bool] = None,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Table = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/projects/{projectId}/datasets/{datasetId}/tables/{tableId}',
    description=""" Updates information in an existing table. The update method replaces the entire table resource, whereas the patch method only replaces fields that are provided in the submitted table resource. """,
    tags=['bigquery_table_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_tables_update(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    table_id: str = Path(..., alias='tableId'),
    autodetect_schema: Optional[bool] = None,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Table = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/datasets/{datasetId}/tables/{tableId}/data',
    description=""" Retrieves table data from a specified set of rows. Requires the READER dataset role. """,
    tags=['bigquery_table_operations', 'bigquery_table_data_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_tabledata_list(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    table_id: str = Path(..., alias='tableId'),
    max_results: Optional[int] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    selected_fields: Optional[str] = Query(None, alias='selectedFields'),
    start_index: Optional[str] = Query(None, alias='startIndex'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{projectId}/datasets/{datasetId}/tables/{tableId}/insertAll',
    description=""" Streams data into BigQuery one record at a time without needing to run a load job. Requires the WRITER dataset role. """,
    tags=['bigquery_table_operations', 'bigquery_table_data_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_tabledata_insert_all(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    table_id: str = Path(..., alias='tableId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TableDataInsertAllRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/datasets/{datasetId}/tables/{tableId}/rowAccessPolicies',
    description=""" Lists all row access policies on the specified table. """,
    tags=['bigquery_table_operations', 'bigquery_table_data_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_row_access_policies_list(
    project_id: str = Path(..., alias='projectId'),
    dataset_id: str = Path(..., alias='datasetId'),
    table_id: str = Path(..., alias='tableId'),
    page_size: Optional[int] = Query(None, alias='pageSize'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/jobs',
    description=""" Lists all jobs that you started in the specified project. Job information is available for a six month period after creation. The job list is sorted in reverse chronological order, by job creation time. Requires the Can View project role, or the Is Owner project role if you set the allUsers property. """,
    tags=['bigquery_job_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_jobs_list(
    project_id: str = Path(..., alias='projectId'),
    all_users: Optional[bool] = Query(None, alias='allUsers'),
    max_creation_time: Optional[str] = Query(None, alias='maxCreationTime'),
    max_results: Optional[int] = Query(None, alias='maxResults'),
    min_creation_time: Optional[str] = Query(None, alias='minCreationTime'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    parent_job_id: Optional[str] = Query(None, alias='parentJobId'),
    projection: Optional[Projection] = None,
    state_filter: Optional[StateFilter] = Query(None, alias='stateFilter'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{projectId}/jobs',
    description=""" Starts a new asynchronous job. Requires the Can View project role. """,
    tags=['bigquery_project_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_jobs_insert(
    project_id: str = Path(..., alias='projectId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    request: Request = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/jobs/{jobId}',
    description=""" Returns information about a specific job. Job information is available for a six month period after creation. Requires that you're the person who ran the job, or have the Is Owner project role. """,
    tags=['bigquery_job_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_jobs_get(
    project_id: str = Path(..., alias='projectId'),
    job_id: str = Path(..., alias='jobId'),
    location: Optional[str] = None,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{projectId}/jobs/{jobId}/cancel',
    description=""" Requests that a job be cancelled. This call will return immediately, and the client will need to poll for the job status to see if the cancel completed successfully. Cancelled jobs may still incur costs. """,
    tags=['bigquery_job_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_jobs_cancel(
    project_id: str = Path(..., alias='projectId'),
    job_id: str = Path(..., alias='jobId'),
    location: Optional[str] = None,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/projects/{projectId}/jobs/{jobId}/delete',
    description=""" Requests the deletion of the metadata of a job. This call returns when the job's metadata is deleted. """,
    tags=['bigquery_job_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_jobs_delete(
    project_id: str = Path(..., alias='projectId'),
    job_id: str = Path(..., alias='jobId'),
    location: Optional[str] = None,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{projectId}/queries',
    description=""" Runs a BigQuery SQL query synchronously and returns query results if the query completes within a specified timeout. """,
    tags=['bigquery_project_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_jobs_query(
    project_id: str = Path(..., alias='projectId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: QueryRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/queries/{jobId}',
    description=""" Retrieves the results of a query job. """,
    tags=['bigquery_job_operations', 'bigquery_query_jobs'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_jobs_get_query_results(
    project_id: str = Path(..., alias='projectId'),
    job_id: str = Path(..., alias='jobId'),
    location: Optional[str] = None,
    max_results: Optional[int] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    start_index: Optional[str] = Query(None, alias='startIndex'),
    timeout_ms: Optional[int] = Query(None, alias='timeoutMs'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{projectId}/serviceAccount',
    description=""" Returns the email address of the service account for your project used for interactions with Google Cloud KMS. """,
    tags=['bigquery_project_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_projects_get_service_account(
    project_id: str = Path(..., alias='projectId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{resource}:getIamPolicy',
    description=""" Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set. """,
    tags=['bigquery_iam_policy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_tables_get_iam_policy(
    resource: str,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: GetIamPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{resource}:setIamPolicy',
    description=""" Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors. """,
    tags=['bigquery_iam_policy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_tables_set_iam_policy(
    resource: str,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: SetIamPolicyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/{resource}:testIamPermissions',
    description=""" Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may "fail open" without warning. """,
    tags=['bigquery_iam_policy_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def bigquery_tables_test_iam_permissions(
    resource: str,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: TestIamPermissionsRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
